"{'name': 'DataFrame.apply',  'api_name': 'DataFrame.apply',  'description': 'Apply a function along an axis of the DataFrame.',  'parameters': {'required': [{'name': 'func', 'description': 'Function to apply to each column or row.'},    {'name': 'axis', 'description': 'Axis along which the function is applied:\\n\\n0 or \u00e2\u0080\u0098index\u00e2\u0080\u0099: apply function to each column.\\n1 or \u00e2\u0080\u0098columns\u00e2\u0080\u0099: apply function to each row.'}],   'optional': [{'name': 'raw', 'description': 'Determines if row or column is passed as a Series or ndarray object:\\n\\nFalse : passes each row or column as a Series to the\\nfunction.\\nTrue : the passed function will receive ndarray objects\\ninstead.\\nIf you are just applying a NumPy reduction function this will\\nachieve much better performance.'},    {'name': 'result_type',     'description': 'These only act when axis=1 (columns):\\n\\n\u00e2\u0080\u0098expand\u00e2\u0080\u0099 : list-like results will be turned into columns.\\n\u00e2\u0080\u0098reduce\u00e2\u0080\u0099 : returns a Series if possible rather than expanding\\nlist-like results. This is the opposite of \u00e2\u0080\u0098expand\u00e2\u0080\u0099.\\n\u00e2\u0080\u0098broadcast\u00e2\u0080\u0099 : results will be broadcast to the original shape\\nof the DataFrame, the original index and columns will be\\nretained.\\n\\nThe default behaviour (None) depends on the return value of the\\napplied function: list-like results will be returned as a Series\\nof those. However if the apply function returns a Series these\\nare expanded to columns.'},    {'name': 'args',     'description': 'Positional arguments to pass to func in addition to the\\narray/series.'},    {'name': 'by_row',     'description': 'Only has an effect when func is a listlike or dictlike of funcs\\nand the func isn\u00e2\u0080\u0099t a string.\\nIf \u00e2\u0080\u009ccompat\u00e2\u0080\u009d, will if possible first translate the func into pandas\\nmethods (e.g. Series().apply(np.sum) will be translated to\\nSeries().sum()). If that doesn\u00e2\u0080\u0099t work, will try call to apply again with\\nby_row=True and if that fails, will call apply again with\\nby_row=False (backward compatible).\\nIf False, the funcs will be passed the whole Series at once.\\n\\nNew in version 2.1.0.'},    {'name': 'engine',     'description': 'Choose between the python (default) engine or the numba engine in apply.\\nThe numba engine will attempt to JIT compile the passed function,\\nwhich may result in speedups for large DataFrames.\\nIt also supports the following engine_kwargs :\\n\\nnopython (compile the function in nopython mode)\\nnogil (release the GIL inside the JIT compiled function)\\nparallel (try to apply the function in parallel over the DataFrame)\\nNote: Due to limitations within numba/how pandas interfaces with numba,\\nyou should only use this if raw=True\\n\\nNote: The numba compiler only supports a subset of\\nvalid Python/numpy operations.\\nPlease read more about the supported python features\\nand supported numpy features\\nin numba to learn what you can or cannot use in the passed function.\\n\\nNew in version 2.2.0.'},    {'name': 'engine_kwargs',     'description': 'Pass keyword arguments to the engine.\\nThis is currently only used by the numba engine,\\nsee the documentation for the engine argument for more information.'},    {'name': '**kwargs',     'description': 'Additional keyword arguments to pass as keywords arguments to\\nfunc.'}]}}"